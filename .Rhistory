options(repos = c(CRAN = "https://cloud.r-project.org"))
options(install.packages.check.source = "no")  # prefer binaries on Windows
install.packages("data.table", type = "binary", dependencies = TRUE)
install.packages("data.table", type = "binary", dependencies = TRUE)
devtools::load_all()
devtools::load_all()
options(repos = c(CRAN = "https://cloud.r-project.org"))
options(install.packages.check.source = "no")  # prefer binaries on Windows
install.packages("data.table", type = "binary", lib = .libPaths()[1])
# sanity checks
"data.table" %in% rownames(installed.packages())
packageVersion("data.table")
# 1) Prefer binaries & set CRAN
options(repos = c(CRAN = "https://cloud.r-project.org"))
options(install.packages.check.source = "no")
# 2) Make sure it's not loaded
try(unloadNamespace("data.table"), silent = TRUE)
# 3) Remove any stale lock folders
locks <- list.files(.libPaths()[1], pattern = "^00LOCK", full.names = TRUE)
if (length(locks)) unlink(locks, recursive = TRUE, force = TRUE)
# 4) If it's still blocking, rename the old folder (works around the locked DLL)
old <- file.path(.libPaths()[1], "data.table")
if (dir.exists(old)) file.rename(old, paste0(old, "_old_", format(Sys.time(), "%H%M%S")))
# 5) Install the binary
install.packages("data.table", type = "binary")
# 6) Verify
packageVersion("data.table")
devtools::load_all()
run_pipeline()
devtools::load_all()
run_pipeline()
devtools::document()
devtools::load_all()
run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
plan_extractions(load_config())[, .(symbol, dims)]
out <- run_pipeline()
devtools::load_all()
list_gdx_names(load_config(), "baseline")[1:50]
devtools::load_all()
out <- run_pipeline()
devtools::document()   # this will add `import(data.table)` to NAMESPACE
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
names(res$derived)
devtools::load_all()
res <- run_pipeline()
names(res$derived)
head(res$derived$TB_t)
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
# --- Investment by industry: 6-group aggregates ----------------------------
I_PP <- rs[["I_PP_t"]]
devtools::load_all()
res <- run_pipeline()
source("C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic/R/derive_indicators.R")
source("C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic/R/derive_indicators.R")
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
View(out)
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
usethis::use_readme_rmd()   # creates README.Rmd, sets .Rbuildignore, knits to README.md
devtools::build_readme()    # re-knit after edits
devtools::build_readme()
devtools::build_readme()
options(install.packages.compile.from.source = "never")
install.packages(c("xfun", "tinytex"), type = "binary", repos = "https://cloud.r-project.org")
install.packages(c("xfun", "tinytex"), type = "binary", repos = "https://cloud.r-project.org")
tinytex::install_tinytex()
devtools::build_vignettes()
rmarkdown::render("vignettes/user_guide.Rmd",
output_format = "pdf_document",
output_dir = "inst/doc")
fidelioDiagnostics::launch_app(
"diagnostic",
outputs_dir = "C:/Users/.../outputs/derived"
)
devtools::load_all()
devtools::document()
fidelioDiagnostics::launch_app("diagnostic")
devtools::document()
devtools::check()
# remove the checked-in doc folder
unlink("inst/doc", recursive = TRUE, force = TRUE)
# tell R build to ignore it if it reappears
cat("^inst/doc$\n", file = ".Rbuildignore", append = TRUE)
# donâ€™t commit it again
cat("inst/doc/\n", file = ".gitignore", append = TRUE)
devtools::document()
devtools::install(dependencies = FALSE, upgrade = "never", build_vignettes = FALSE)
devtools::load_all()
cfg <- load_config()
print_runtime_info(cfg)
res <- run_pipeline()
fidelioDiagnostics::launch_app("diagnostic", project_root = getwd())
library(devtools)
document(); load_all()   # pick up the latest code
getwd()
normalizePath(c(
"config/project.yml",
"outputs/derived",
"outputs/derived/manifest.rds",
"outputs/derived/manifest.csv"
), mustWork = FALSE)
list.files("outputs/derived")[1:20]
cfg <- load_config()
str(cfg$paths)
file.path(getwd(), cfg$paths$outputs, "derived")
# launch_app in the *installed/loaded* package
fidelioDiagnostics::launch_app
# internal helpers (triple colon)
fidelioDiagnostics:::resolve_outputs_dir
fidelioDiagnostics:::outputs_dir_from_config
fidelioDiagnostics:::resolve_project_root
# launch_app in the *installed/loaded* package
fidelioDiagnostics::launch_app
fidelioDiagnostics:::resolve_outputs_dir
fidelioDiagnostics:::outputs_dir_from_config
fidelioDiagnostics:::resolve_project_root
fidelioDiagnostics:::outputs_dir_from_config(root = getwd())
source("C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic/R/app_loaders.R")
fidelioDiagnostics:::outputs_dir_from_config(config_path = "config/project.yml")
fidelioDiagnostics::launch_app(
"diagnostic",
outputs_dir = normalizePath("outputs/derived", mustWork = TRUE)
)
devtools::document()
devtools::install(quick = TRUE, build_vignettes = FALSE, dependencies = FALSE, upgrade = "never")
.rs.restartR(); library(fidelioDiagnostics)
fidelioDiagnostics:::resolve_project_root
fidelioDiagnostics:::outputs_dir_from_config(root = getwd())
fidelioDiagnostics:::outputs_dir_from_config(config_path = "config/project.yml")
fidelioDiagnostics::launch_app("diagnostic", project_root = getwd())
library(fidelioDiagnostics)
# 1) Load config and print paths
cfg <- load_config()
print_runtime_info(cfg)
fidelioDiagnostics::launch_app("diagnostic", project_root = getwd())
