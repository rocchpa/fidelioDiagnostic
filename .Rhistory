options(repos = c(CRAN = "https://cloud.r-project.org"))
options(install.packages.check.source = "no")  # prefer binaries on Windows
install.packages("data.table", type = "binary", dependencies = TRUE)
install.packages("data.table", type = "binary", dependencies = TRUE)
devtools::load_all()
devtools::load_all()
options(repos = c(CRAN = "https://cloud.r-project.org"))
options(install.packages.check.source = "no")  # prefer binaries on Windows
install.packages("data.table", type = "binary", lib = .libPaths()[1])
# sanity checks
"data.table" %in% rownames(installed.packages())
packageVersion("data.table")
# 1) Prefer binaries & set CRAN
options(repos = c(CRAN = "https://cloud.r-project.org"))
options(install.packages.check.source = "no")
# 2) Make sure it's not loaded
try(unloadNamespace("data.table"), silent = TRUE)
# 3) Remove any stale lock folders
locks <- list.files(.libPaths()[1], pattern = "^00LOCK", full.names = TRUE)
if (length(locks)) unlink(locks, recursive = TRUE, force = TRUE)
# 4) If it's still blocking, rename the old folder (works around the locked DLL)
old <- file.path(.libPaths()[1], "data.table")
if (dir.exists(old)) file.rename(old, paste0(old, "_old_", format(Sys.time(), "%H%M%S")))
# 5) Install the binary
install.packages("data.table", type = "binary")
# 6) Verify
packageVersion("data.table")
devtools::load_all()
run_pipeline()
devtools::load_all()
run_pipeline()
devtools::document()
devtools::load_all()
run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
plan_extractions(load_config())[, .(symbol, dims)]
out <- run_pipeline()
devtools::load_all()
list_gdx_names(load_config(), "baseline")[1:50]
devtools::load_all()
out <- run_pipeline()
devtools::document()   # this will add `import(data.table)` to NAMESPACE
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
out <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
names(res$derived)
devtools::load_all()
res <- run_pipeline()
names(res$derived)
head(res$derived$TB_t)
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
# --- Investment by industry: 6-group aggregates ----------------------------
I_PP <- rs[["I_PP_t"]]
devtools::load_all()
res <- run_pipeline()
source("C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic/R/derive_indicators.R")
source("C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic/R/derive_indicators.R")
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
View(out)
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
devtools::load_all()
res <- run_pipeline()
usethis::use_readme_rmd()   # creates README.Rmd, sets .Rbuildignore, knits to README.md
devtools::build_readme()    # re-knit after edits
devtools::build_readme()
devtools::build_readme()
options(install.packages.compile.from.source = "never")
install.packages(c("xfun", "tinytex"), type = "binary", repos = "https://cloud.r-project.org")
install.packages(c("xfun", "tinytex"), type = "binary", repos = "https://cloud.r-project.org")
tinytex::install_tinytex()
devtools::build_vignettes()
rmarkdown::render("vignettes/user_guide.Rmd",
output_format = "pdf_document",
output_dir = "inst/doc")
fidelioDiagnostics::launch_app(
"diagnostic",
outputs_dir = "C:/Users/.../outputs/derived"
)
devtools::load_all()
devtools::document()
fidelioDiagnostics::launch_app("diagnostic")
devtools::document()
devtools::check()
# remove the checked-in doc folder
unlink("inst/doc", recursive = TRUE, force = TRUE)
# tell R build to ignore it if it reappears
cat("^inst/doc$\n", file = ".Rbuildignore", append = TRUE)
# don’t commit it again
cat("inst/doc/\n", file = ".gitignore", append = TRUE)
devtools::document()
devtools::install(dependencies = FALSE, upgrade = "never", build_vignettes = FALSE)
devtools::load_all()
cfg <- load_config()
print_runtime_info(cfg)
res <- run_pipeline()
fidelioDiagnostics::launch_app("diagnostic", project_root = getwd())
library(devtools)
document(); load_all()   # pick up the latest code
getwd()
normalizePath(c(
"config/project.yml",
"outputs/derived",
"outputs/derived/manifest.rds",
"outputs/derived/manifest.csv"
), mustWork = FALSE)
list.files("outputs/derived")[1:20]
cfg <- load_config()
str(cfg$paths)
file.path(getwd(), cfg$paths$outputs, "derived")
# launch_app in the *installed/loaded* package
fidelioDiagnostics::launch_app
# internal helpers (triple colon)
fidelioDiagnostics:::resolve_outputs_dir
fidelioDiagnostics:::outputs_dir_from_config
fidelioDiagnostics:::resolve_project_root
# launch_app in the *installed/loaded* package
fidelioDiagnostics::launch_app
fidelioDiagnostics:::resolve_outputs_dir
fidelioDiagnostics:::outputs_dir_from_config
fidelioDiagnostics:::resolve_project_root
fidelioDiagnostics:::outputs_dir_from_config(root = getwd())
source("C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic/R/app_loaders.R")
fidelioDiagnostics:::outputs_dir_from_config(config_path = "config/project.yml")
fidelioDiagnostics::launch_app(
"diagnostic",
outputs_dir = normalizePath("outputs/derived", mustWork = TRUE)
)
devtools::document()
devtools::install(quick = TRUE, build_vignettes = FALSE, dependencies = FALSE, upgrade = "never")
.rs.restartR(); library(fidelioDiagnostics)
fidelioDiagnostics:::resolve_project_root
fidelioDiagnostics:::outputs_dir_from_config(root = getwd())
fidelioDiagnostics:::outputs_dir_from_config(config_path = "config/project.yml")
fidelioDiagnostics::launch_app("diagnostic", project_root = getwd())
library(fidelioDiagnostics)
# 1) Load config and print paths
cfg <- load_config()
print_runtime_info(cfg)
fidelioDiagnostics::launch_app("diagnostic", project_root = getwd())
cfg <- load_config()
library(fidelioDiagnostics)
cfg <- load_config()
devtools::load_all()
fidelioDiagnostics::run_pipeline()
getwd()
file.exists("config/project.yml")
# from the project root
devtools::document()   # optional but good
devtools::install(quiet = TRUE)
devtools::load_all()
devtools::document()
devtools::install()
.rs.restartR()         # restart the R session
getwd()
library(fidelioDiagnostics)
cfg <- fidelioDiagnostics:::load_config()  # no arguments
cfg$paths$gdx_dir   # should include your subfolder (e.g. .../data-raw/gdx/eta_cpi_025_beta_infl_1)
cfg$paths$outputs
library(yaml)
# A. Confirm the two config files are there
file.exists("config/default.yml")
file.exists("config/project.yml")
# B. What do they actually say?
d <- yaml::read_yaml("config/default.yml")
p <- yaml::read_yaml("config/project.yml")
d <- yaml::read_yaml("config/default.yml")
p <- yaml::read_yaml("config/project.yml")
library(yaml)
# must be TRUE
file.exists("config/default.yml")
file.exists("config/project.yml")
d <- yaml::read_yaml("config/default.yml")
p <- yaml::read_yaml("config/project.yml")
library(fidelioDiagnostics)
cfg <- fidelioDiagnostics:::load_config(verbose = TRUE)
library(fidelioDiagnostics)
cfg <- fidelioDiagnostics:::load_config(v)
library(fidelioDiagnostics)
cfg <- fidelioDiagnostics:::load_config()
cfg$paths$gdx_dir
unlink(file.path(cfg$paths$outputs, "derived"), recursive = TRUE, force = TRUE)
unlink(file.path(cfg$paths$outputs, "base"),    recursive = TRUE, force = TRUE)
run_pipeline()
library(fidelioDiagnostics)
fidelioDiagnostics::launch_app("diagnostic", project_root = getwd())
fidelioDiagnostics::launch_app("results", project_root = getwd())
devtools::document()
devtools::load_all()
devtools::document()
devtools::install()
library(fidelioDiagnostics)
fidelioDiagnostics::run_pipeline()
getAnywhere("export_results_csv")
devtools::document(); devtools::load_all()
getAnywhere("export_results_csv")
"export_results_csv" %in% getNamespaceExports("fidelioDiagnostics")
od <- fidelioDiagnostics:::outputs_dir_from_config()
od
list.files(od, recursive = TRUE, pattern = "results_bundle|template|csv", full.names = TRUE)
bun <- file.path(od, "bundle_results_app.rds")
cfg <- fidelioDiagnostics:::load_config()
str(cfg$export_csv)
fidelioDiagnostics::export_results_csv(cfg = cfg)
Q   # (capital Q) to exit the debugger
getwd()
# 2) Load config explicitly (this should now succeed)
cfg <- fidelioDiagnostics:::load_config()
str(cfg$paths)          # sanity check you see lists, not NULL/strings
library(fidelioDiagnostics)
# 1) Load config and print paths
cfg <- load_config()
print_runtime_info(cfg)
res <- run_pipeline()
str(cfg$paths)
od <- fidelioDiagnostics:::outputs_dir_from_config(cfg)
file.exists(file.path(od, "bundle_results_app.rds"))
# 1) Use the outputs path from cfg directly
cfg <- fidelioDiagnostics:::load_config()
# This is the folder where bundles + derived files live:
od <- file.path(cfg$paths$outputs, "derived")
od
dir.exists(od) || dir.create(od, recursive = TRUE)
bun <- file.path(od, "bundle_results_app.rds")
bun; file.exists(bun)
fidelioDiagnostics::export_results_csv(cfg = cfg)
vlibrary(fidelioDiagnostics)
library(fidelioDiagnostics)
# 1) Load config and print paths
cfg <- load_config()
devtools::document()
devtools::load_all()
cfg <- fidelioDiagnostics:::load_config()
fidelioDiagnostics::export_results_csv(cfg = cfg)
q
cfg <- fidelioDiagnostics::load_config()
root <- "C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic"
setwd(root)
# sanity: these must be TRUE
file.exists("config/default.yml"); file.exists("config/project.yml")
# 2) Load config now that we’re in the right folder
cfg <- fidelioDiagnostics:::load_config()
str(cfg$paths)   # should show a list with gdx_dir, outputs, cache
library(yaml)
def <- yaml::read_yaml("config/default.yml")
prj <- yaml::read_yaml("config/project.yml")
# print top-level keys that have a type clash
check_types <- function(x, y, path="") {
bad <- character()
for (nm in intersect(names(x), names(y))) {
px <- paste0(path, nm)
if (is.list(x[[nm]]) && is.list(y[[nm]])) {
bad <- c(bad, check_types(x[[nm]], y[[nm]], paste0(px, ".")))
} else if (is.list(x[[nm]]) != is.list(y[[nm]])) {
bad <- c(bad, px)
}
}
bad
}
clashes <- check_types(def, prj)
clashes
devtools::document()
devtools::load_all()
cfg <- load_config()
# 2) Run the pipeline: extract → wide → aggregates → derived → save
res <- run_pipeline()
library(data.table)
p <- file.path(cfg$paths$outputs, "derived", "results_bundle_template.csv")
DT <- fread(p)
DT[variable != "" & !is.na(variable)][1:10]
DT[variable == "" | is.na(variable)][, .N]  # should be 0
unique(DT[grepl("^GDPr", variable), unit])  # should be "million EUR"
devtools::document()
devtools::load_all()
cfg <- load_config()
# 2) Run the pipeline: extract → wide → aggregates → derived → save
res <- run_pipeline()
source("C:/Users/Rocchi/CMCC Dropbox/Paola Rocchi/SPAGHETTI/FIDELIO coupling materials/2025/090925_investments_diagnostic/fidelioDiagnostic/R/R2csv.R")
devtools::document()
rm(list = "export_results_csv")
library(fidelioDiagnostics)
# make sure R2csv.R is saved under your package's R/ folder
devtools::document()
devtools::load_all()   # this loads the PACKAGE version
# sanity: confirm only the package version exists
getAnywhere("export_results_csv")$where
# run it
cfg <- fidelioDiagnostics:::load_config()
fidelioDiagnostics::export_results_csv(cfg = cfg)   # use :: now that it’s exported
devtools::check()                        # optional but recommended
library(fidelioDiagnostics)
devtools::load_all()
devtools::document()
devtools::build_readme()
warnings()
devtools::build_readme()
library(fidelioDiagnostics)
devtools::build_readme()
library(fidelioDiagnostics)
cfg <- load_config()
launch_app("results")
library(fidelioDiagnostics)
cfg <- load_config()
devtools::document()
devtools::load_all()
cfg <- load_config()
# if you changed roxygen tags (e.g., @export), do this once:
devtools::document()
# load all R/ files and register exports
devtools::load_all()
export_results_csv()
export_results_csv()
library(fidelioDiagnostics)
library(gdxrrw)
# Load configuration and print paths
cfg <- load_config()
launch_app("results")
R.version
library(fidelioDiagnostics)
# keep a console open at the package root
devtools::document()   # only when roxygen/exports changed
devtools::load_all()
devtools::build_readme()
devtools::build_readme()
devtools::build_readme()
devtools::build_readme()
